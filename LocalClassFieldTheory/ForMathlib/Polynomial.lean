import FieldTheory.Ratfunc
import RingTheory.DedekindDomain.AdicValuation

#align_import for_mathlib.polynomial

/-!
# Polynomials
This file contains general result concerning the coercion of polynomials to power series and to
Hahn series in general and it is meant to expand the current `mathlib` library.#check

## Main Definitions
* `ideal_X` is the term of the height-one spectrum of the polynomial ring with coefficients in a
  field `K` represented by the principal ideal `X`.
* We obtain an `instance : valued (ratfunc K) ℤₘ₀` of a valued field on the rational functions by
  using the `ideal_X`-adic valuation.

## Main Results
* `val_X_eq_neg_one` is the result that the `ideal_X`-adic valuation of `X` equals
  `multiplicative.of_add (-1 : ℤ)`


-/


open IsDedekindDomain

noncomputable section

open scoped Classical DiscreteValuation

namespace IsDedekindDomain.HeightOneSpectrum

variable {R : Type _} [CommRing R] [IsDomain R] [IsDedekindDomain R] {K : Type _} [Field K]
  [Algebra R K] [IsFractionRing R K] (v : HeightOneSpectrum R)

theorem intValuation_singleton {r : R} (hr : r ≠ 0) (hv : v.asIdeal = Ideal.span {r}) :
    v.intValuation r = Multiplicative.ofAdd (-1 : ℤ) :=
  by
  have h : v.int_valuation r = v.int_valuation_def r := rfl
  rw [h, v.int_valuation_def_if_neg hr, ← hv, Associates.count_self, algebraMap.coe_one]
  apply v.associates_irreducible

-- much faster than doing this inside the rw
end IsDedekindDomain.HeightOneSpectrum

variable (K : Type _) [Field K]

noncomputable section

open IsDedekindDomain.HeightOneSpectrum

namespace Polynomial

/-- This is the principal ideal generated by `X` in the ring of polynomials over a field K,
  regarded as an element of the height-one-spectrum. -/
def idealX : IsDedekindDomain.HeightOneSpectrum (Polynomial K)
    where
  asIdeal := Ideal.span {X}
  IsPrime := by rw [Ideal.span_singleton_prime]; exacts [prime_X, X_ne_zero]
  ne_bot := by rw [Ne.def, Ideal.span_singleton_eq_bot]; exact X_ne_zero

@[simp]
theorem idealX_span : (idealX K).asIdeal = Ideal.span {Polynomial.X} :=
  rfl

theorem val_x_eq_neg_one :
    (idealX K).Valuation (RatFunc.X : RatFunc K) = Multiplicative.ofAdd (-1 : ℤ) :=
  by
  rw [← RatFunc.algebraMap_X, valuation_of_algebra_map, int_valuation_singleton]
  · exact X_ne_zero
  -- times out if within the rw (?)
  · exact ideal_X_span K

--same (?)
end Polynomial

namespace RatFunc

open Polynomial

instance : Valued (RatFunc K) ℤₘ₀ :=
  Valued.mk' (idealX K).Valuation

theorem WithZero.valued_def {x : RatFunc K} :
    @Valued.v (RatFunc K) _ _ _ (RatFunc.WithZero.valued K) x = (idealX K).Valuation x :=
  rfl

end RatFunc

