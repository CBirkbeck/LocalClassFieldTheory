import RingTheory.DedekindDomain.Ideal

#align_import for_mathlib.ring_theory.dedekind_domain.ideal

/-!
# Ideals in Dedekind Domains

## Main Results

* `count_normalized_factors_eq_count_normalized_factors_span` says that the `count` of the
normalized factors of an element `r : R` in a ring `R` equal to a prime element `X` coincides with
the `count` of the normalized factors of the ideal generated by `r` equal to the ideal generated by
`X`.
* `count_normalized_factors_eq_associates_count` equates the `count` of normalized factors for
ideals with the `count` of the respective associated elements.
-/


open UniqueFactorizationMonoid

open scoped Classical

namespace NormalizationMonoid

theorem count_normalizedFactors_eq_count_normalizedFactors_span {R : Type _} [CommRing R]
    [IsDomain R] [IsPrincipalIdealRing R] [NormalizationMonoid R] [DecidableEq R]
    [DecidableEq (Ideal R)] {r X : R} (hr : r ≠ 0) (hX₀ : X ≠ 0) (hX₁ : normUnit X = 1)
    (hX : Prime X) :
    Multiset.count X (normalizedFactors r) =
      Multiset.count (Ideal.span {X} : Ideal R) (normalizedFactors (Ideal.span {r})) :=
  by
  replace hX₁ : X = normalize X
  · simp only [normalize_apply, hX₁, Units.val_one, mul_one]
  have : (Ideal.span {normalize X} : Ideal R) = normalize (Ideal.span {X}) :=
    by
    simp only [normalize_apply, normalize_eq]
    apply Ideal.span_singleton_mul_right_unit (Units.isUnit _)
  rw [← PartENat.natCast_inj, hX₁, ← multiplicity_eq_count_normalized_factors hX.irreducible hr,
    this, ← multiplicity_eq_multiplicity_span, ← multiplicity_eq_count_normalized_factors]
  refine' Prime.irreducible (Ideal.prime_of_isPrime _ _)
  · rwa [Ne.def, Ideal.span_singleton_eq_bot]
  · rwa [Ideal.span_singleton_prime hX₀]
  · rwa [Ne.def, Ideal.zero_eq_bot, Ideal.span_singleton_eq_bot]

theorem count_normalizedFactors_eq_associates_count (R : Type _) [CommRing R] [IsDomain R]
    [IsPrincipalIdealRing R] (I J : Ideal R) (hI : I ≠ 0) (hJ : J.IsPrime) (hJ₀ : J ≠ ⊥) :
    Multiset.count J (normalizedFactors I) = (Associates.mk J).count (Associates.mk I).factors :=
  by
  replace hI : Associates.mk I ≠ 0
  · apply associates.mk_ne_zero.mpr hI
  have hJ' : Irreducible (Associates.mk J) :=
    by
    rw [Associates.irreducible_mk]
    apply Prime.irreducible
    apply Ideal.prime_of_isPrime hJ₀ hJ
  apply Ideal.count_normalizedFactors_eq
  rw [← Ideal.dvd_iff_le, ← Associates.mk_dvd_mk, Associates.mk_pow, Associates.dvd_eq_le,
    Associates.prime_pow_dvd_iff_le hI hJ']
  · rw [← Ideal.dvd_iff_le, ← Associates.mk_dvd_mk, Associates.mk_pow, Associates.dvd_eq_le,
      Associates.prime_pow_dvd_iff_le hI hJ']
    linarith

end NormalizationMonoid

